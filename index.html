<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameMaker Fixture Editor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e, #2d2d42);
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        .container { display: flex; height: 100vh; }
        .sidebar {
            width: 340px; /* Sidebar biraz geni≈ületildi */
            background: rgba(45, 45, 66, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
            display: flex; flex-direction: column;
        }
        .main-area {
            flex: 1; display: flex; flex-direction: column; background: #1a1a2e;
        }
        .toolbar {
            height: 60px; background: rgba(30, 30, 46, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; align-items: center; padding: 0 20px; gap: 15px;
        }
        .canvas-container {
            flex: 1; position: relative; overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #16213e, #0f3460);
        }
        canvas { position: absolute; cursor: crosshair; background: transparent; }
        .section { margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 15px; }
        .section:last-child { border-bottom: none; }
        .section h3 {
            color: #64ffda; margin-bottom: 12px; font-size: 15px; display: flex; align-items: center; gap: 8px;
        }
        .file-input { position: relative; overflow: hidden; display: inline-block; width: 100%; }
        .file-input input[type=file] { position: absolute; left: -9999px; }
        .file-input label {
            display: block; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; text-align: center; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; font-size: 13px;
        }
        .file-input label:hover { transform: translateY(-1px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.3s ease; font-size: 13px; }
        .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .btn-secondary { background: linear-gradient(135deg, #f093fb, #f5576c); color: white; }
        .btn-success { background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
        .info-panel { background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.05); }
        .info-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 12px; }
        .info-label { color: #a0a0a0; }
        .points-list {
            max-height: 150px; overflow-y: auto; background: rgba(0, 0, 0, 0.2);
            border-radius: 6px; padding: 5px; margin-top: 10px;
        }
        .point-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; margin-bottom: 2px; background: rgba(255, 255, 255, 0.03);
            border-radius: 4px; font-size: 11px;
        }
        .point-item:hover { background: rgba(255, 255, 255, 0.08); }
        .point-delete { background: none; border: none; color: #ff4757; cursor: pointer; font-size: 14px; padding: 0 5px; }
        .code-output {
            background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px;
            font-family: 'Courier New', monospace; font-size: 11px; color: #aaffaa;
            height: 150px; overflow-y: auto; white-space: pre-wrap; line-height: 1.4; resize: vertical;
        }
        .mode-buttons { display: flex; gap: 5px; margin-bottom: 10px; }
        .mode-btn {
            flex: 1; padding: 6px; border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent; color: #aaa; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .mode-btn.active { background: rgba(100, 255, 218, 0.2); border-color: #64ffda; color: #64ffda; }
        .shape-type-container { display: flex; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 4px; margin-bottom: 10px; }
        .shape-type-btn {
            flex: 1; border: none; background: transparent; color: #888; padding: 6px;
            border-radius: 4px; cursor: pointer; font-size: 12px; text-align: center;
        }
        .shape-type-btn.active { background: #667eea; color: white; font-weight: bold; }
        .zoom-controls { display: flex; align-items: center; gap: 5px; }
        .zoom-btn {
            width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05); color: white; border-radius: 4px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        
        /* Warning Boxes */
        .warning {
            background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107;
            color: #ffca2c; padding: 8px; border-radius: 0 4px 4px 0;
            font-size: 11px; margin-top: 10px; line-height: 1.4;
        }
        
        .important-note {
            background: rgba(64, 100, 255, 0.1);
            border-left: 3px solid #4064ff;
            color: #aaccff;
            padding: 8px;
            font-size: 11px;
            margin-bottom: 15px;
            border-radius: 0 4px 4px 0;
            line-height: 1.4;
        }
        
        input[type="range"] { width: 100%; height: 4px; background: #444; border-radius: 2px; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #64ffda; border-radius: 50%; cursor: pointer; }
        
        .lang-select {
            width: 100%; padding: 8px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1); color: #fff;
            border-radius: 6px; margin-bottom: 20px; cursor: pointer;
        }
        .lang-select option { background: #2d2d42; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <!-- Language Selector -->
            <select id="langSelect" class="lang-select" onchange="setLanguage(this.value)">
                <option value="en" selected>üá∫üá∏ English</option>
                <option value="tr">üáπüá∑ T√ºrk√ße</option>
            </select>

            <div class="section">
                <h3 data-i18n="sprite_upload">üñºÔ∏è Sprite Upload</h3>
                <div class="file-input">
                    <input type="file" id="spriteFile" accept="image/*">
                    <label for="spriteFile" data-i18n="select_file">Select File...</label>
                </div>
                <div id="spriteInfo" style="font-size: 11px; color: #888; margin-top: 5px; text-align: center;" data-i18n="no_sprite">No sprite loaded</div>
            </div>

            <div class="section">
                <h3 data-i18n="tools">üõ†Ô∏è Tools</h3>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="add" data-i18n="btn_add" data-i18n-title="btn_add_title" title="Add Point">‚ûï Add</button>
                    <button class="mode-btn" data-mode="move" data-i18n="btn_move" data-i18n-title="btn_move_title" title="Move Point">‚úã Move</button>
                </div>
                
                <div style="margin-bottom: 5px; font-size: 12px; color: #aaa;" data-i18n="shape_algo">Shape Algorithm:</div>
                <div class="shape-type-container">
                    <button class="shape-type-btn active" onclick="setShapeType('convex')" data-i18n="mode_convex">Convex (Auto)</button>
                    <button class="shape-type-btn" onclick="setShapeType('concave')" data-i18n="mode_concave">Concave (Free)</button>
                </div>
                
                <div class="grid-controls">
                    <label style="display:flex; align-items:center; gap:5px; font-size:12px; color:#aaa;">
                        <input type="checkbox" id="showGrid" checked> <span data-i18n="show_grid">Show Grid</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:5px; font-size:12px; color:#aaa;">
                        <input type="checkbox" id="snapToGrid"> <span data-i18n="snap_grid">Snap to Grid</span>
                    </label>
                </div>
                
                <div class="info-row">
                    <span class="info-label">Grid: <span id="gridSizeValue">20px</span></span>
                    <input type="range" id="gridSize" min="8" max="64" value="20" style="width: 60%">
                </div>
            </div>

            <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3><span data-i18n="points_header">üìç Points</span> (<span id="pointCount">0</span>)</h3>
                    <button class="btn-secondary" style="padding: 2px 8px; font-size: 10px;" onclick="clearAllPoints()" data-i18n="btn_clear">Clear</button>
                </div>
                <div class="points-list" id="pointsList"></div>
            </div>

            <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 data-i18n="physics_settings">‚öôÔ∏è Physics Settings</h3>
                    <button style="background:none; border:none; color:#64ffda; cursor:pointer; font-size:10px;" onclick="resetPhysics()" data-i18n="btn_reset">Reset</button>
                </div>
                <div class="info-panel">
                    <div class="info-row">
                        <span>Density</span>
                        <input type="number" id="density" value="0.5" step="0.1" style="width:50px; background:#222; border:1px solid #444; color:#fff; border-radius:3px;">
                    </div>
                    <div class="info-row">
                        <span>Restitution</span>
                        <input type="number" id="restitution" value="0.1" step="0.1" style="width:50px; background:#222; border:1px solid #444; color:#fff; border-radius:3px;">
                    </div>
                    <div class="info-row">
                        <span>Friction</span>
                        <input type="number" id="friction" value="0.2" step="0.1" style="width:50px; background:#222; border:1px solid #444; color:#fff; border-radius:3px;">
                    </div>
                    <div class="info-row">
                        <span>Collision Group</span>
                        <input type="number" id="group" value="1" style="width:50px; background:#222; border:1px solid #444; color:#fff; border-radius:3px;">
                    </div>
                    <div style="margin-top:5px; display:flex; gap:10px;">
                        <label style="font-size:11px; color:#aaa;"><input type="checkbox" id="sensor"> Sensor</label>
                        <label style="font-size:11px; color:#aaa;"><input type="checkbox" id="awake" checked> Awake</label>
                    </div>
                </div>
            </div>

            <div class="section" style="flex: 1; display: flex; flex-direction: column;">
                <!-- YENƒ∞ EKLENEN UYARI B√ñL√úM√ú -->
                <div class="important-note" data-i18n="important_note">
                    <b>Important:</b> In your Object's physics settings, under "Modify Collision Shape", set the "Physics Collision Shape" type to "Convex Shape" and leave it empty.
                </div>

                <h3 data-i18n="gml_code">üìã GML Code</h3>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <button class="btn btn-success" style="flex:1" onclick="generateCode()" data-i18n="btn_generate">Generate Code</button>
                    <button class="btn btn-primary" style="flex:1" onclick="copyCode()" data-i18n="btn_copy" id="copyBtn">Copy</button>
                </div>
                <div class="code-output" id="codeOutput">// Code will appear here...</div>
                <div class="warning" id="warningMsg"></div>
            </div>
        </div>

        <div class="main-area">
            <div class="toolbar">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="changeZoom(-0.1)">-</button>
                    <span id="zoomLevel" style="font-size: 12px; width: 40px; text-align: center;">100%</span>
                    <button class="zoom-btn" onclick="changeZoom(0.1)">+</button>
                </div>
                <button class="btn btn-secondary" onclick="resetView()" data-i18n="btn_center">Center View</button>
                <div style="flex:1"></div>
                <div style="font-size: 12px; color: #aaa;">
                    Mouse: <span id="mouseX">0</span>, <span id="mouseY">0</span>
                </div>
            </div>
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- TRANSLATIONS ---
        const translations = {
            en: {
                sprite_upload: "üñºÔ∏è Sprite Upload",
                select_file: "Select File...",
                no_sprite: "No sprite loaded",
                tools: "üõ†Ô∏è Tools",
                btn_add: "‚ûï Add",
                btn_add_title: "Add Point",
                btn_move: "‚úã Move",
                btn_move_title: "Move Point",
                shape_algo: "Shape Algorithm:",
                mode_convex: "Convex (Auto)",
                mode_concave: "Concave (Free)",
                show_grid: "Show Grid",
                snap_grid: "Snap to Grid",
                points_header: "üìç Points",
                btn_clear: "Clear",
                physics_settings: "‚öôÔ∏è Physics Settings",
                btn_reset: "Reset",
                gml_code: "üìã GML Code",
                btn_generate: "Generate Code",
                btn_copy: "Copy",
                btn_center: "Center View",
                btn_copied: "Copied!",
                
                // Dynamic Messages
                important_note: "<b>Important:</b> In your Object's physics settings, under \"Modify Collision Shape\", set the \"Physics Collision Shape\" type to \"Convex Shape\" and leave it empty.",
                msg_convex: "Convex mode: Points are automatically sorted, concavities are removed.",
                msg_concave: "Concave mode: Draw points <b>clockwise</b> and sequentially. The shape will be triangulated.",
                msg_min_points: "Need at least 3 points!",
                msg_code_placeholder: "// Code will appear here...",
                
                // Code Comments
                code_fixture_create: "// Fixture Creation Code",
                code_warning_limit: "// WARNING: Box2D supports max 8 points per convex polygon.",
                code_warning_auto: "// Convex hull was generated but has more than 8 points.",
                code_warning_error: "// GameMaker might throw an error.",
                code_concave_split: "// Concave shape split into {n} triangles.",
                code_part: "// Part {n}"
            },
            tr: {
                sprite_upload: "üñºÔ∏è Sprite Y√ºkle",
                select_file: "Dosya Se√ß...",
                no_sprite: "Hen√ºz sprite y√ºklenmedi",
                tools: "üõ†Ô∏è Ara√ßlar",
                btn_add: "‚ûï Ekle",
                btn_add_title: "Nokta Ekle",
                btn_move: "‚úã Ta≈üƒ±",
                btn_move_title: "Nokta Ta≈üƒ±",
                shape_algo: "≈ûekil Algoritmasƒ±:",
                mode_convex: "Convex (Otomatik)",
                mode_concave: "Concave (Serbest)",
                show_grid: "Grid G√∂ster",
                snap_grid: "Grid'e Yapƒ±≈ütƒ±r",
                points_header: "üìç Noktalar",
                btn_clear: "Temizle",
                physics_settings: "‚öôÔ∏è Fizik Ayarlarƒ±",
                btn_reset: "Sƒ±fƒ±rla",
                gml_code: "üìã GML Kodu",
                btn_generate: "Kod √úret",
                btn_copy: "Kopyala",
                btn_center: "Merkezle",
                btn_copied: "Kopyalandƒ±!",

                // Dinamik Mesajlar
                important_note: "<b>√ñnemli:</b> Objenizin fizik ayarlarƒ± b√∂l√ºm√ºnden \"Modify Collision Shape\" b√∂l√ºm√ºnden \"Physics Collision Shape\" tipini \"Convex Shape\" yapƒ±p bo≈ü bƒ±rakƒ±n.",
                msg_convex: "Convex modu: Noktalar otomatik sƒ±ralanƒ±r, i√ßb√ºkeylikler kapatƒ±lƒ±r.",
                msg_concave: "Concave modu: Noktalarƒ± <b>saat y√∂n√ºnde</b> ve sƒ±rasƒ±yla √ßizmelisiniz. ≈ûekil √º√ßgenlere b√∂l√ºn√ºr.",
                msg_min_points: "En az 3 nokta gerekli!",
                msg_code_placeholder: "// Kod buraya gelecek...",

                // Kod Yorumlarƒ±
                code_fixture_create: "// Fixture Olu≈üturma Kodu",
                code_warning_limit: "// UYARI: Box2D convex polygon ba≈üƒ±na en fazla 8 nokta destekler.",
                code_warning_auto: "// Otomatik olarak convex hull alƒ±ndƒ± ancak 8'den fazla nokta var.",
                code_warning_error: "// GameMaker bunu √ßalƒ±≈ütƒ±rƒ±rken hata verebilir.",
                code_concave_split: "// Concave ≈üekil {n} adet √º√ßgene b√∂l√ºnd√º.",
                code_part: "// Par√ßa {n}"
            }
        };

        let currentLang = 'en';

        // --- TEMEL DEƒûƒ∞≈ûKENLER ---
        let canvas, ctx;
        let sprite = null;
        let points = [];
        let mode = 'add'; 
        let shapeType = 'convex'; 
        let selectedPoint = -1;
        let isDragging = false;
        let camera = { x: 0, y: 0, zoom: 1 };
        let gridSize = 20;
        let showGrid = true;
        let snapToGrid = false;

        // --- BA≈ûLATMA ---
        window.onload = () => {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            
            // Dil Ayarƒ±
            setLanguage('en');

            window.addEventListener('resize', resizeCanvas);
            document.getElementById('spriteFile').addEventListener('change', handleFile);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            
            // UI Kontrolleri
            document.querySelectorAll('.mode-btn').forEach(b => {
                b.addEventListener('click', function() {
                    document.querySelector('.mode-btn.active').classList.remove('active');
                    this.classList.add('active');
                    mode = this.dataset.mode;
                    selectedPoint = -1;
                });
            });

            document.getElementById('showGrid').addEventListener('change', e => showGrid = e.target.checked);
            document.getElementById('snapToGrid').addEventListener('change', e => snapToGrid = e.target.checked);
            document.getElementById('gridSize').addEventListener('input', function() {
                gridSize = parseInt(this.value);
                document.getElementById('gridSizeValue').innerText = gridSize + 'px';
            });

            resizeCanvas();
            resetView();
            loop();
        };

        // --- Dƒ∞L FONKSƒ∞YONLARI ---
        function t(key) {
            return translations[currentLang][key] || key;
        }

        function setLanguage(lang) {
            currentLang = lang;
            
            // HTML elementleri g√ºncelle
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if(translations[lang][key]) el.innerHTML = translations[lang][key];
            });
            
            // Title (tooltip) g√ºncelle
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if(translations[lang][key]) el.title = translations[lang][key];
            });

            // Dinamik alanlarƒ± g√ºncelle
            updateWarningMsg();
            document.getElementById('codeOutput').innerText = t('msg_code_placeholder');
        }

        function updateWarningMsg() {
            const warning = document.getElementById('warningMsg');
            if(shapeType === 'convex') {
                warning.innerHTML = t('msg_convex');
                warning.style.borderLeftColor = "#ffc107";
                warning.style.color = "#ffca2c";
            } else {
                warning.innerHTML = t('msg_concave');
                warning.style.borderLeftColor = "#ff4757";
                warning.style.color = "#ff6b81";
            }
        }

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        function setShapeType(type) {
            shapeType = type;
            document.querySelectorAll('.shape-type-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            updateWarningMsg();
        }

        function handleFile(e) {
            const file = e.target.files[0];
            if(!file) return;
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    sprite = { img: img, w: img.width, h: img.height };
                    document.getElementById('spriteInfo').innerText = `${file.name} (${sprite.w}x${sprite.h})`;
                    camera.zoom = Math.min((canvas.width*0.8)/sprite.w, (canvas.height*0.8)/sprite.h);
                    camera.x = canvas.width/2;
                    camera.y = canvas.height/2;
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - camera.x) / camera.zoom,
                y: (e.clientY - rect.top - camera.y) / camera.zoom
            };
        }

        function onMouseDown(e) {
            const m = getMousePos(e);
            
            if(mode === 'add') {
                let px = m.x, py = m.y;
                if(snapToGrid) {
                    px = Math.round(px/gridSize)*gridSize;
                    py = Math.round(py/gridSize)*gridSize;
                }
                points.push({x: px, y: py});
                updatePointsList();
            } else {
                let minDist = 10 / camera.zoom;
                selectedPoint = -1;
                points.forEach((p, i) => {
                    const d = Math.hypot(p.x - m.x, p.y - m.y);
                    if(d < minDist) {
                        minDist = d;
                        selectedPoint = i;
                    }
                });
                if(selectedPoint !== -1) isDragging = true;
            }
        }

        function onMouseMove(e) {
            const m = getMousePos(e);
            document.getElementById('mouseX').innerText = Math.round(m.x);
            document.getElementById('mouseY').innerText = Math.round(m.y);

            if(isDragging && selectedPoint !== -1) {
                let px = m.x, py = m.y;
                if(snapToGrid) {
                    px = Math.round(px/gridSize)*gridSize;
                    py = Math.round(py/gridSize)*gridSize;
                }
                points[selectedPoint] = {x: px, y: py};
                updatePointsList();
            }
        }

        function onMouseUp() { isDragging = false; }

        function onWheel(e) {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            changeZoom(factor - 1);
        }

        function changeZoom(delta) {
            let oldZoom = camera.zoom;
            if(Math.abs(delta) < 0.5) camera.zoom *= (1 + delta);
            else camera.zoom = delta;
            
            camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
            document.getElementById('zoomLevel').innerText = Math.round(camera.zoom*100) + '%';
        }

        function resetView() {
            camera.x = canvas.width / 2;
            camera.y = canvas.height / 2;
            camera.zoom = 1;
            changeZoom(0);
        }

        function updatePointsList() {
            const list = document.getElementById('pointsList');
            document.getElementById('pointCount').innerText = points.length;
            list.innerHTML = '';
            
            points.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'point-item';
                div.innerHTML = `
                    <span>${i+1}: (${Math.round(p.x)}, ${Math.round(p.y)})</span>
                    <button class="point-delete" onclick="deletePoint(${i})">√ó</button>
                `;
                list.appendChild(div);
            });
        }

        function deletePoint(i) {
            points.splice(i, 1);
            updatePointsList();
        }
        
        function clearAllPoints() {
            points = [];
            updatePointsList();
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(showGrid) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 1;
                const startX = (camera.x % (gridSize*camera.zoom)) - (gridSize*camera.zoom);
                const startY = (camera.y % (gridSize*camera.zoom)) - (gridSize*camera.zoom);
                
                for(let x = startX; x < canvas.width; x += gridSize*camera.zoom) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                }
                for(let y = startY; y < canvas.height; y += gridSize*camera.zoom) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                }
                
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath(); ctx.moveTo(camera.x, 0); ctx.lineTo(camera.x, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, camera.y); ctx.lineTo(canvas.width, camera.y); ctx.stroke();
                ctx.restore();
            }

            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            if(sprite) {
                ctx.drawImage(sprite.img, -sprite.w/2, -sprite.h/2);
            }

            if(points.length > 0) {
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1 / camera.zoom;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                if(points.length > 2) ctx.closePath();
                ctx.stroke();

                if(points.length >= 3) {
                    if(shapeType === 'convex') {
                        const hull = getConvexHull([...points]);
                        ctx.strokeStyle = '#64ffda';
                        ctx.lineWidth = 2 / camera.zoom;
                        ctx.fillStyle = 'rgba(100, 255, 218, 0.2)';
                        ctx.beginPath();
                        ctx.moveTo(hull[0].x, hull[0].y);
                        for(let i=1; i<hull.length; i++) ctx.lineTo(hull[i].x, hull[i].y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        const triangles = triangulatePolygon([...points]);
                        triangles.forEach(tri => {
                            ctx.strokeStyle = '#ff6b81';
                            ctx.lineWidth = 2 / camera.zoom;
                            ctx.fillStyle = 'rgba(255, 107, 129, 0.2)';
                            ctx.beginPath();
                            ctx.moveTo(tri[0].x, tri[0].y);
                            ctx.lineTo(tri[1].x, tri[1].y);
                            ctx.lineTo(tri[2].x, tri[2].y);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        });
                    }
                }

                points.forEach((p, i) => {
                    ctx.fillStyle = (i === selectedPoint) ? '#fff' : '#f093fb';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4/camera.zoom, 0, Math.PI*2);
                    ctx.fill();
                });
            }

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function getConvexHull(pts) {
            if(pts.length < 3) return pts;
            let cx=0, cy=0;
            pts.forEach(p => { cx+=p.x; cy+=p.y; });
            cx/=pts.length; cy/=pts.length;
            pts.sort((a, b) => Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx));
            return pts; 
        }

        function triangulatePolygon(pts) {
            let vertices = pts.slice();
            let triangles = [];
            if (vertices.length < 3) return [];

            let count = 0;
            const maxCount = vertices.length * 3; 

            while (vertices.length > 3) {
                if(count++ > maxCount) break;
                let earFound = false;
                for (let i = 0; i < vertices.length; i++) {
                    const prev = vertices[(i - 1 + vertices.length) % vertices.length];
                    const curr = vertices[i];
                    const next = vertices[(i + 1) % vertices.length];

                    if (isEar(prev, curr, next, vertices)) {
                        triangles.push([prev, curr, next]);
                        vertices.splice(i, 1);
                        earFound = true;
                        break;
                    }
                }
                if (!earFound) {
                    triangles.push([vertices[0], vertices[1], vertices[2]]);
                    vertices.shift();
                }
            }
            triangles.push([vertices[0], vertices[1], vertices[2]]);
            return triangles;
        }

        function isEar(p1, p2, p3, polygon) {
            if (!isConvex(p1, p2, p3)) return false;
            for (let i = 0; i < polygon.length; i++) {
                const p = polygon[i];
                if (p === p1 || p === p2 || p === p3) continue;
                if (pointInTriangle(p, p1, p2, p3)) return false;
            }
            return true;
        }

        function isConvex(a, b, c) {
            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) >= 0; 
        }

        function pointInTriangle(p, a, b, c) {
            const area = 0.5 * (-b.y * c.x + a.y * (-b.x + c.x) + a.x * (b.y - c.y) + b.x * c.y);
            const s = 1 / (2 * area) * (a.y * c.x - a.x * c.y + (c.y - a.y) * p.x + (a.x - c.x) * p.y);
            const t = 1 / (2 * area) * (a.x * b.y - a.y * b.x + (a.y - b.y) * p.x + (b.x - a.x) * p.y);
            return s > 0 && t > 0 && (1 - s - t) > 0;
        }

        function generateCode() {
            if(points.length < 3) {
                alert(t('msg_min_points'));
                return;
            }

            const props = {
                density: document.getElementById('density').value,
                restitution: document.getElementById('restitution').value,
                friction: document.getElementById('friction').value,
                group: document.getElementById('group').value,
                sensor: document.getElementById('sensor').checked,
                awake: document.getElementById('awake').checked
            };

            let code = `${t('code_fixture_create')}\n`;
            code += `var fix, points;\n\n`;

            if(shapeType === 'convex') {
                const hull = getConvexHull([...points]);
                
                if(hull.length > 8) {
                    code += `${t('code_warning_limit')}\n`;
                    code += `${t('code_warning_auto')}\n`;
                    code += `${t('code_warning_error')}\n`;
                }

                code += `fix = physics_fixture_create();\n`;
                code += `physics_fixture_set_polygon_shape(fix);\n`;
                
                hull.forEach(p => {
                    code += `physics_fixture_add_point(fix, ${Math.round(p.x)}, ${Math.round(p.y)});\n`;
                });

                code += generatePropsCode('fix', props);
                code += `physics_fixture_bind(fix, id);\n`;
                code += `physics_fixture_delete(fix);\n`;

            } else {
                const triangles = triangulatePolygon([...points]);
                code += `${t('code_concave_split').replace('{n}', triangles.length)}\n\n`;

                triangles.forEach((tri, i) => {
                    code += `${t('code_part').replace('{n}', i+1)}\n`;
                    code += `fix = physics_fixture_create();\n`;
                    code += `physics_fixture_set_polygon_shape(fix);\n`;
                    
                    tri.forEach(p => {
                        code += `physics_fixture_add_point(fix, ${Math.round(p.x)}, ${Math.round(p.y)});\n`;
                    });

                    code += generatePropsCode('fix', props);
                    code += `physics_fixture_bind(fix, id);\n`;
                    code += `physics_fixture_delete(fix);\n\n`;
                });
            }

            document.getElementById('codeOutput').innerText = code;
        }

        function generatePropsCode(varName, p) {
            return `physics_fixture_set_density(${varName}, ${p.density});
physics_fixture_set_restitution(${varName}, ${p.restitution});
physics_fixture_set_friction(${varName}, ${p.friction});
physics_fixture_set_collision_group(${varName}, ${p.group});
physics_fixture_set_sensor(${varName}, ${p.sensor});
physics_fixture_set_awake(${varName}, ${p.awake});
physics_fixture_set_linear_damping(${varName}, 0.1);
physics_fixture_set_angular_damping(${varName}, 0.1);
`;
        }

        function copyCode() {
            const range = document.createRange();
            range.selectNode(document.getElementById('codeOutput'));
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            
            const btn = document.getElementById('copyBtn');
            const oldText = btn.innerText;
            btn.innerText = t('btn_copied');
            setTimeout(() => btn.innerText = oldText, 1500);
        }
        
        function resetPhysics() {
            document.getElementById('density').value = 0.5;
            document.getElementById('restitution').value = 0.1;
            document.getElementById('friction').value = 0.2;
            document.getElementById('group').value = 1;
            document.getElementById('sensor').checked = false;
            document.getElementById('awake').checked = true;
        }
    </script>
</body>
</html>